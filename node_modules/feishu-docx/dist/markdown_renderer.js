"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MarkdownRenderer = void 0;
const feishu_docx_1 = require("feishu-docx");
const js_yaml_1 = __importDefault(require("js-yaml"));
const marked_1 = require("marked");
const dom_1 = require("./dom");
const emoji_1 = require("./emoji");
const string_buffer_1 = require("./string_buffer");
const renderer_1 = require("./renderer");
const types_1 = require("./types");
/**
 * Markdown Renderer
 *
 * Convert Feishu Docx to Markdown GFM
 *
 * This is inspired by feishu2md (Go version)
 * https://github.com/Wsine/feishu2md/blob/cb906109235b07b82b5a6348bdf1103c9fa1e62c/core/parser.go
 */
class MarkdownRenderer extends renderer_1.Renderer {
    parseBlock(block, indent) {
        if (!block) {
            return '';
        }
        const buf = new string_buffer_1.Buffer();
        buf.write(' '.repeat(indent * 4));
        switch (block.block_type) {
            case types_1.BlockType.Page:
                buf.write(this.parsePageBlock(block));
                break;
            case types_1.BlockType.Text:
                buf.write(this.parseTextBlock(block.text));
                break;
            case types_1.BlockType.Heading1:
                buf.write('# ');
                buf.write(this.parseTextBlock(block.heading1));
                break;
            case types_1.BlockType.Heading2:
                buf.write('## ');
                buf.write(this.parseTextBlock(block.heading2));
                break;
            case types_1.BlockType.Heading3:
                buf.write('### ');
                buf.write(this.parseTextBlock(block.heading3));
                break;
            case types_1.BlockType.Heading4:
                buf.write('#### ');
                buf.write(this.parseTextBlock(block.heading4));
                break;
            case types_1.BlockType.Heading5:
                buf.write('##### ');
                buf.write(this.parseTextBlock(block.heading5));
                break;
            case types_1.BlockType.Heading6:
                buf.write('###### ');
                buf.write(this.parseTextBlock(block.heading6));
                break;
            case types_1.BlockType.Heading7:
                buf.write('####### ');
                buf.write(this.parseTextBlock(block.heading7));
                break;
            case types_1.BlockType.Heading8:
                buf.write('######## ');
                buf.write(this.parseTextBlock(block.heading8));
                break;
            case types_1.BlockType.Heading9:
                buf.write('######### ');
                buf.write(this.parseTextBlock(block.heading9));
                break;
            case types_1.BlockType.Bullet:
                buf.write(this.parseBulletBlock(block, indent));
                break;
            case types_1.BlockType.Ordered:
                buf.write(this.parseOrderedBlock(block, indent));
                break;
            case types_1.BlockType.Code:
                buf.write('```');
                buf.write((0, types_1.getCodeLanguage)(block.code.style.language));
                buf.write('\n');
                buf.write(this.parseTextBlock(block.code).trim());
                buf.write('\n```\n');
                break;
            case types_1.BlockType.Quote:
                buf.write('> ');
                buf.write(this.parseTextBlock(block.quote));
                break;
            case types_1.BlockType.TodoList:
                buf.write('- [');
                buf.write(block.todo.style.done ? 'x' : ' ');
                buf.write('] ');
                buf.write(this.parseTextBlock(block.todo));
                break;
            case types_1.BlockType.Divider:
                buf.write('---\n');
                break;
            case types_1.BlockType.Image:
                buf.write(this.parseImage(block.image));
                break;
            case types_1.BlockType.TableCell:
                buf.write(this.parseTableCell(block));
                break;
            case types_1.BlockType.Table:
                buf.write(this.parseTable(block.table));
                break;
            case types_1.BlockType.QuoteContainer:
                buf.write(this.parseQuoteContainer(block));
                break;
            case types_1.BlockType.View:
                buf.write(this.parseView(block));
                break;
            case types_1.BlockType.File:
                buf.write(this.parseFile(block));
                break;
            case types_1.BlockType.Grid:
                buf.write(this.parseGrid(block));
                break;
            case types_1.BlockType.GridColumn:
                break;
            case types_1.BlockType.Callout:
                buf.write(this.parseCallout(block));
                break;
            case types_1.BlockType.Iframe:
                buf.write(this.parseIframe(block));
                break;
            case types_1.BlockType.SyncedBlock:
                buf.write(this.parseSyncedBlock(block));
                break;
            default:
                buf.write(this.parseUnsupport(block));
                break;
        }
        return buf.toString();
    }
    /**
     * Parse this first block as PageMeta
     *
     * Return false if not found first code block.
     * Otherwise return true if parsed as YAML, false if not YAML.
     *
     * https://longbridgeapp.github.io/feishu-pages/zh-CN/page-meta
     *
     * @param block
     * @returns
     */
    parsePageMeta(block) {
        var _a, _b, _c, _d, _e;
        if ((block === null || block === void 0 ? void 0 : block.block_type) !== types_1.BlockType.Code) {
            if (((_a = block.children) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                return this.parsePageMeta(this.blockMap[block.children[0]]);
            }
            else {
                return false;
            }
        }
        // Only support YAML
        if (((_c = (_b = block === null || block === void 0 ? void 0 : block.code) === null || _b === void 0 ? void 0 : _b.style) === null || _c === void 0 ? void 0 : _c.language) !== feishu_docx_1.CodeLanguage.YAML) {
            return false;
        }
        let code = this.parseTextBlock(block.code).trim();
        if (!code) {
            return false;
        }
        const language = (_e = (_d = block === null || block === void 0 ? void 0 : block.code) === null || _d === void 0 ? void 0 : _d.style) === null || _e === void 0 ? void 0 : _e.language;
        try {
            if (language === feishu_docx_1.CodeLanguage.YAML) {
                this.meta = js_yaml_1.default.load(code);
            }
            else if (language === feishu_docx_1.CodeLanguage.JSON) {
                this.meta = JSON.parse(code);
            }
        }
        catch (_f) {
            console.error(`Invalid ${language} content, ignored.\n\n` + code);
        }
        return true;
    }
    parsePageBlock(block) {
        var _a;
        const buf = new string_buffer_1.Buffer();
        buf.write('# ');
        buf.write(this.parseTextBlock(block.page));
        buf.write('\n');
        (_a = block.children) === null || _a === void 0 ? void 0 : _a.forEach((childId, idx) => {
            const child = this.blockMap[childId];
            this.nextBlock = this.blockMap[block.children[idx + 1]];
            // Extract PageMeta from first code block
            if (idx == 0) {
                if (this.parsePageMeta(child)) {
                    return;
                }
            }
            let childText = this.parseBlock(child, 0);
            if (childText.length > 0) {
                buf.write(childText);
                buf.write('\n');
            }
        });
        return buf.toString();
    }
    parseTextBlock(block) {
        var _a;
        const buf = new string_buffer_1.Buffer();
        const inline = block.elements.length > 1;
        (_a = block.elements) === null || _a === void 0 ? void 0 : _a.forEach((el) => {
            buf.write(this.parseTextElement(el, inline));
        });
        if (buf.length > 0) {
            buf.write('\n');
        }
        return buf.toString();
    }
    parseBulletBlock(block, indent = 0) {
        var _a, _b, _c, _d;
        const buf = new string_buffer_1.Buffer();
        buf.write('- ');
        let itemText = this.parseTextBlock(block.bullet);
        if (((_a = this.nextBlock) === null || _a === void 0 ? void 0 : _a.block_type) == block.block_type &&
            ((_b = this.nextBlock) === null || _b === void 0 ? void 0 : _b.parent_id) == block.parent_id &&
            !((_c = block.children) === null || _c === void 0 ? void 0 : _c.length)) {
            itemText = (0, renderer_1.trimLastNewline)(itemText);
        }
        buf.write(itemText);
        (_d = block.children) === null || _d === void 0 ? void 0 : _d.forEach((childId, idx) => {
            const child = this.blockMap[childId];
            this.nextBlock = null;
            buf.write(this.parseBlock(child, indent + 1));
        });
        return buf.toString();
    }
    parseOrderedBlock(block, indent = 0) {
        var _a, _b, _c, _d, _e;
        const buf = new string_buffer_1.Buffer();
        const parent = this.blockMap[block.parent_id];
        let order = 1;
        // Calc the order number
        (_a = parent === null || parent === void 0 ? void 0 : parent.children) === null || _a === void 0 ? void 0 : _a.forEach((childId, idx) => {
            if (childId == block.block_id) {
                for (let i = idx - 1; i >= 0; i--) {
                    if (this.blockMap[parent.children[i]].block_type == types_1.BlockType.Ordered) {
                        order++;
                    }
                    else {
                        break;
                    }
                }
            }
        });
        buf.write(`${order}. `);
        let itemText = this.parseTextBlock(block.ordered);
        if (((_b = this.nextBlock) === null || _b === void 0 ? void 0 : _b.block_type) == block.block_type &&
            ((_c = this.nextBlock) === null || _c === void 0 ? void 0 : _c.parent_id) == block.parent_id &&
            !((_d = block.children) === null || _d === void 0 ? void 0 : _d.length)) {
            itemText = (0, renderer_1.trimLastNewline)(itemText);
        }
        buf.write(itemText);
        // Sub items
        (_e = block.children) === null || _e === void 0 ? void 0 : _e.forEach((childId, idx) => {
            const child = this.blockMap[childId];
            // Peek next block
            this.nextBlock = null;
            buf.write(this.parseBlock(child, indent + 1));
        });
        return buf.toString();
    }
    parseTextElement(el, inline) {
        const buf = new string_buffer_1.Buffer();
        if (el.text_run) {
            buf.write(this.parseTextRun(el.text_run));
        }
        else if (el.equation) {
            let symbol = inline ? '$' : '$$';
            buf.write(symbol);
            buf.write(el.equation.content.trimEnd());
            buf.write(symbol);
        }
        else if (el.mention_doc) {
            const node_token = decodeURIComponent(el.mention_doc.token);
            buf.write(`[${el.mention_doc.title}](${node_token})`);
        }
        return buf.toString();
    }
    parseTextRun(textRun) {
        const buf = new string_buffer_1.Buffer();
        let postWrite = '';
        let style = textRun.text_element_style;
        if (style) {
            if (style.bold) {
                buf.write('**');
                postWrite = '**';
            }
            else if (style.italic) {
                buf.write('_');
                postWrite = '_';
            }
            else if (style.strikethrough) {
                buf.write('~~');
                postWrite = '~~';
            }
            else if (style.underline) {
                buf.write('<u>');
                postWrite = '</u>';
            }
            else if (style.inline_code) {
                buf.write('`');
                postWrite = '`';
            }
            else if (style.link) {
                const unescapeURL = decodeURIComponent(style.link.url);
                buf.write(`[`);
                postWrite = `](${unescapeURL})`;
            }
        }
        buf.write(textRun.content || '');
        buf.write(postWrite);
        return buf.toString();
    }
    parseImage(image) {
        const buf = new string_buffer_1.Buffer();
        const align = (0, types_1.getAlignStyle)(image.align);
        let alignAttr = '';
        if (align != 'left') {
            alignAttr = ` align="${align}"`;
        }
        const el = (0, dom_1.createElement)('img');
        el.setAttribute('src', image.token);
        if (image.width) {
            el.setAttribute('src-width', image.width.toString());
        }
        // Only give height when width is not given
        if (image.height) {
            el.setAttribute('src-height', image.height.toString());
        }
        if (align && align != 'left') {
            el.setAttribute('align', align);
        }
        buf.write(el.outerHTML);
        buf.write('\n');
        this.addFileToken('image', image.token);
        return buf.toString();
    }
    parseTableCell(block) {
        var _a;
        const buf = new string_buffer_1.Buffer();
        (_a = block.children) === null || _a === void 0 ? void 0 : _a.forEach((childId) => {
            const child = this.blockMap[childId];
            buf.write(this.parseBlock(child, 0));
        });
        return buf.toString();
    }
    parseTable(table) {
        var _a, _b, _c;
        let rows = [[]];
        table.cells.forEach((blockId, idx) => {
            const block = this.blockMap[blockId];
            let cellText = this.parseBlock(block, 0);
            cellText = (0, renderer_1.trimLastNewline)(cellText).replace(/\n/gm, '<br/>');
            const row = Math.floor(idx / table.property.column_size);
            if (rows.length < row + 1) {
                rows.push([]);
            }
            rows[row].push(cellText);
        });
        const buf = new string_buffer_1.Buffer();
        // Write thead
        let headRow = [];
        if ((_a = table.property) === null || _a === void 0 ? void 0 : _a.header_row) {
            headRow = rows.shift();
        }
        buf.write('|');
        for (let i = 0; i < ((_b = table.property) === null || _b === void 0 ? void 0 : _b.column_size); i++) {
            buf.write(headRow[i] || '   ');
            buf.write('|');
        }
        buf.write('\n');
        // Render thead divider
        buf.write('|');
        for (let i = 0; i < ((_c = table.property) === null || _c === void 0 ? void 0 : _c.column_size); i++) {
            buf.write('---|');
        }
        buf.write('\n');
        // Render tbody
        for (const row of rows) {
            buf.write('|');
            row.forEach((cell) => {
                buf.write(cell);
                buf.write('|');
            });
            buf.write('\n');
        }
        return buf.toString();
    }
    parseQuoteContainer(block) {
        var _a;
        const buf = new string_buffer_1.Buffer();
        (_a = block.children) === null || _a === void 0 ? void 0 : _a.forEach((childId) => {
            const child = this.blockMap[childId];
            buf.write('> ');
            buf.write(this.parseBlock(child, 0));
        });
        return buf.toString();
    }
    parseView(block) {
        var _a;
        const buf = new string_buffer_1.Buffer();
        (_a = block.children) === null || _a === void 0 ? void 0 : _a.forEach((childId) => {
            const child = this.blockMap[childId];
            buf.write(this.parseBlock(child, 0));
        });
        return buf.toString();
    }
    parseFile(block) {
        const buf = new string_buffer_1.Buffer();
        const file = block.file;
        this.addFileToken('file', file.token);
        buf.write(`[${file.name}](${file.token})`);
        buf.write('\n');
        return buf.toString();
    }
    parseGrid(block) {
        var _a;
        const buf = new string_buffer_1.Buffer();
        buf.write(`<div class="grid gap-3 grid-cols-${block.grid.column_size}">\n`);
        (_a = block.children) === null || _a === void 0 ? void 0 : _a.forEach((childId) => {
            const child = this.blockMap[childId];
            buf.write(this.parseGridColumn(child));
        });
        buf.write('</div>\n');
        return buf.toString();
    }
    parseGridColumn(block) {
        var _a;
        const buf = new string_buffer_1.Buffer();
        buf.write(`<div>\n`);
        let innerBuf = new string_buffer_1.Buffer();
        (_a = block.children) === null || _a === void 0 ? void 0 : _a.forEach((childId) => {
            const child = this.blockMap[childId];
            innerBuf.write(this.parseBlock(child, 0));
        });
        buf.write(this.markdownToHTML(innerBuf.toString()));
        buf.write('</div>\n');
        return buf.toString();
    }
    parseCallout(block) {
        var _a;
        const buf = new string_buffer_1.Buffer();
        const style = {};
        const classNames = ['callout'];
        if (block.callout.background_color) {
            const backgroundColor = types_1.CalloutBackgroundColorMap[block.callout.background_color];
            style['background'] = backgroundColor;
            classNames.push(`callout-bg-${block.callout.background_color}`);
        }
        if (block.callout.border_color) {
            const borderColor = types_1.CalloutBorderColorMap[block.callout.border_color];
            style['border'] = `1px solid ${borderColor}`;
            classNames.push(`callout-border-${block.callout.border_color}`);
        }
        if (block.callout.text_color) {
            const textColor = types_1.FontColorMap[block.callout.text_color] || '#2222';
            style['color'] = textColor;
            classNames.push(`callout-color-${block.callout.text_color}`);
        }
        const styleAttr = Object.keys(style)
            .map((key) => {
            return `${key}: ${style[key]}`;
        })
            .join('; ');
        buf.write(`<div class="${classNames.join(' ')}">\n`);
        // Inner of the Callout, we need ouput as HTML
        let markdownBuf = new string_buffer_1.Buffer();
        if (block.callout.emoji_id) {
            markdownBuf.write((0, emoji_1.getEmojiChar)(block.callout.emoji_id));
            markdownBuf.write(' ');
        }
        (_a = block.children) === null || _a === void 0 ? void 0 : _a.forEach((childId) => {
            const child = this.blockMap[childId];
            markdownBuf.write(this.parseBlock(child, 0));
        });
        let html = this.markdownToHTML(markdownBuf.toString());
        buf.write(html);
        buf.write('</div>\n');
        return buf.toString();
    }
    parseIframe(block) {
        var _a, _b;
        let buf = new string_buffer_1.Buffer();
        let url = (_b = (_a = block.iframe) === null || _a === void 0 ? void 0 : _a.component) === null || _b === void 0 ? void 0 : _b.url;
        if (!url)
            return '';
        const el = (0, dom_1.createElement)('iframe');
        el.setAttribute('src', decodeURIComponent(block.iframe.component.url));
        buf.write(el.outerHTML);
        buf.write('\n');
        return buf.toString();
    }
    parseSyncedBlock(block) {
        var _a;
        const buf = new string_buffer_1.Buffer();
        (_a = block.children) === null || _a === void 0 ? void 0 : _a.forEach((childId) => {
            const child = this.blockMap[childId];
            buf.write(this.parseBlock(child, 0));
        });
        return buf.toString();
    }
    parseUnsupport(block) {
        if (!this.outputUnsupported) {
            return '';
        }
        const buf = new string_buffer_1.Buffer();
        buf.write('```\n');
        buf.write(`// [Unsupport] ${types_1.BlockType[block.block_type]}\n`);
        buf.write(JSON.stringify(block, null, 2));
        buf.write('\n```\n');
        return buf.toString();
    }
    markdownToHTML(markdown) {
        let html = marked_1.marked.parse(markdown, { gfm: true, breaks: true });
        return html;
    }
}
exports.MarkdownRenderer = MarkdownRenderer;
//# sourceMappingURL=markdown_renderer.js.map