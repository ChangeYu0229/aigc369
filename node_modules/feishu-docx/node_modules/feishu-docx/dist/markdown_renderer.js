"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MarkdownRenderer = void 0;
const dom_1 = require("./dom");
const string_buffer_1 = require("./string_buffer");
const types_1 = require("./types");
/**
 * Markdown Renderer
 *
 * Convert Feishu Docx to Markdown GFM
 *
 * This is inspired by feishu2md (Go version)
 * https://github.com/Wsine/feishu2md/blob/cb906109235b07b82b5a6348bdf1103c9fa1e62c/core/parser.go
 */
class MarkdownRenderer extends types_1.Renderer {
    parseBlock(block, indent) {
        if (!block) {
            return '';
        }
        const buf = new string_buffer_1.Buffer();
        buf.write(' '.repeat(indent * 4));
        switch (block.block_type) {
            case types_1.BlockType.Page:
                buf.write(this.parsePageBlock(block));
                break;
            case types_1.BlockType.Text:
                buf.write(this.parseTextBlock(block.text));
                break;
            case types_1.BlockType.Heading1:
                buf.write('# ');
                buf.write(this.parseTextBlock(block.heading1));
                break;
            case types_1.BlockType.Heading2:
                buf.write('## ');
                buf.write(this.parseTextBlock(block.heading2));
                break;
            case types_1.BlockType.Heading3:
                buf.write('### ');
                buf.write(this.parseTextBlock(block.heading3));
                break;
            case types_1.BlockType.Heading4:
                buf.write('#### ');
                buf.write(this.parseTextBlock(block.heading4));
                break;
            case types_1.BlockType.Heading5:
                buf.write('##### ');
                buf.write(this.parseTextBlock(block.heading5));
                break;
            case types_1.BlockType.Heading6:
                buf.write('###### ');
                buf.write(this.parseTextBlock(block.heading6));
                break;
            case types_1.BlockType.Heading7:
                buf.write('####### ');
                buf.write(this.parseTextBlock(block.heading7));
                break;
            case types_1.BlockType.Heading8:
                buf.write('######## ');
                buf.write(this.parseTextBlock(block.heading8));
                break;
            case types_1.BlockType.Heading9:
                buf.write('######### ');
                buf.write(this.parseTextBlock(block.heading9));
                break;
            case types_1.BlockType.Bullet:
                buf.write(this.parseBulletBlock(block, indent));
                break;
            case types_1.BlockType.Ordered:
                buf.write(this.parseOrderedBlock(block, indent));
                break;
            case types_1.BlockType.Code:
                buf.write('```');
                buf.write((0, types_1.getCodeLanguage)(block.code.style.language));
                buf.write('\n');
                buf.write(this.parseTextBlock(block.code).trim());
                buf.write('\n```\n');
                break;
            case types_1.BlockType.Quote:
                buf.write('> ');
                buf.write(this.parseTextBlock(block.quote));
                break;
            case types_1.BlockType.TodoList:
                buf.write('- [');
                buf.write(block.todo.style.done ? 'x' : ' ');
                buf.write('] ');
                buf.write(this.parseTextBlock(block.todo));
                break;
            case types_1.BlockType.Divider:
                buf.write('---\n');
                break;
            case types_1.BlockType.Image:
                buf.write(this.parseImage(block.image));
                break;
            case types_1.BlockType.TableCell:
                buf.write(this.parseTableCell(block));
                break;
            case types_1.BlockType.Table:
                buf.write(this.parseTable(block.table));
                break;
            case types_1.BlockType.QuoteContainer:
                buf.write(this.parseQuoteContainer(block));
                break;
            case types_1.BlockType.View:
                buf.write(this.parseView(block));
                break;
            case types_1.BlockType.File:
                buf.write(this.parseFile(block));
                break;
            default:
                buf.write(this.parseUnsupport(block));
                break;
        }
        return buf.toString();
    }
    parsePageBlock(block) {
        var _a;
        const buf = new string_buffer_1.Buffer();
        buf.write('# ');
        buf.write(this.parseTextBlock(block.page));
        buf.write('\n');
        let listBlocks = [];
        let lastBlock = null;
        (_a = block.children) === null || _a === void 0 ? void 0 : _a.forEach((childId, idx) => {
            const child = this.blockMap[childId];
            this.nextBlock = this.blockMap[block.children[idx + 1]];
            let childText = this.parseBlock(child, 0);
            if (childText.length > 0) {
                buf.write(childText);
                buf.write('\n');
            }
            lastBlock = child;
        });
        return buf.toString();
    }
    parseTextBlock(block) {
        var _a;
        const buf = new string_buffer_1.Buffer();
        const inline = block.elements.length > 1;
        (_a = block.elements) === null || _a === void 0 ? void 0 : _a.forEach((el) => {
            buf.write(this.parseTextElement(el, inline));
        });
        if (buf.length > 0) {
            buf.write('\n');
        }
        return buf.toString();
    }
    parseBulletBlock(block, indent = 0) {
        var _a, _b, _c, _d;
        const buf = new string_buffer_1.Buffer();
        buf.write('- ');
        let itemText = this.parseTextBlock(block.bullet);
        if (((_a = this.nextBlock) === null || _a === void 0 ? void 0 : _a.block_type) == block.block_type &&
            ((_b = this.nextBlock) === null || _b === void 0 ? void 0 : _b.parent_id) == block.parent_id &&
            !((_c = block.children) === null || _c === void 0 ? void 0 : _c.length)) {
            itemText = (0, types_1.trimLastNewline)(itemText);
        }
        buf.write(itemText);
        (_d = block.children) === null || _d === void 0 ? void 0 : _d.forEach((childId, idx) => {
            const child = this.blockMap[childId];
            this.nextBlock = null;
            buf.write(this.parseBlock(child, indent + 1));
        });
        return buf.toString();
    }
    parseOrderedBlock(block, indent = 0) {
        var _a, _b, _c, _d, _e;
        const buf = new string_buffer_1.Buffer();
        const parent = this.blockMap[block.parent_id];
        let order = 1;
        // Calc the order number
        (_a = parent === null || parent === void 0 ? void 0 : parent.children) === null || _a === void 0 ? void 0 : _a.forEach((childId, idx) => {
            if (childId == block.block_id) {
                for (let i = idx - 1; i >= 0; i--) {
                    if (this.blockMap[parent.children[i]].block_type == types_1.BlockType.Ordered) {
                        order++;
                    }
                    else {
                        break;
                    }
                }
            }
        });
        buf.write(`${order}. `);
        let itemText = this.parseTextBlock(block.ordered);
        if (((_b = this.nextBlock) === null || _b === void 0 ? void 0 : _b.block_type) == block.block_type &&
            ((_c = this.nextBlock) === null || _c === void 0 ? void 0 : _c.parent_id) == block.parent_id &&
            !((_d = block.children) === null || _d === void 0 ? void 0 : _d.length)) {
            itemText = (0, types_1.trimLastNewline)(itemText);
        }
        buf.write(itemText);
        // Sub items
        (_e = block.children) === null || _e === void 0 ? void 0 : _e.forEach((childId, idx) => {
            const child = this.blockMap[childId];
            // Peek next block
            this.nextBlock = null;
            buf.write(this.parseBlock(child, indent + 1));
        });
        return buf.toString();
    }
    parseTextElement(el, inline) {
        const buf = new string_buffer_1.Buffer();
        if (el.text_run) {
            buf.write(this.parseTextRun(el.text_run));
        }
        else if (el.equation) {
            let symbol = inline ? '$' : '$$';
            buf.write(symbol);
            buf.write(el.equation.content.trimEnd());
            buf.write(symbol);
        }
        else if (el.mention_doc) {
            const url = decodeURIComponent(el.mention_doc.url);
            buf.write(`[${el.mention_doc.title}](${url})`);
        }
        return buf.toString();
    }
    parseTextRun(textRun) {
        const buf = new string_buffer_1.Buffer();
        let postWrite = '';
        let style = textRun.text_element_style;
        if (style) {
            if (style.bold) {
                buf.write('**');
                postWrite = '**';
            }
            else if (style.italic) {
                buf.write('_');
                postWrite = '_';
            }
            else if (style.strikethrough) {
                buf.write('~~');
                postWrite = '~~';
            }
            else if (style.underline) {
                buf.write('<u>');
                postWrite = '</u>';
            }
            else if (style.inline_code) {
                buf.write('`');
                postWrite = '`';
            }
            else if (style.link) {
                const unescapeURL = decodeURIComponent(style.link.url);
                buf.write(`[`);
                postWrite = `](${unescapeURL})`;
            }
        }
        buf.write(textRun.content || '');
        buf.write(postWrite);
        return buf.toString();
    }
    parseImage(image) {
        const buf = new string_buffer_1.Buffer();
        const align = (0, types_1.getAlignStyle)(image.align);
        let alignAttr = '';
        if (align != 'left') {
            alignAttr = ` align="${align}"`;
        }
        const el = (0, dom_1.createElement)('img');
        el.setAttribute('src', image.token);
        if (image.width) {
            el.setAttribute('width', image.width.toString());
        }
        // Only give height when width is not given
        if (!image.width && image.height) {
            el.setAttribute('height', image.height.toString());
        }
        if (align && align != 'left') {
            el.setAttribute('align', align);
        }
        buf.write(el.outerHTML);
        buf.write('\n');
        this.imageTokens.push(image.token);
        return buf.toString();
    }
    parseTableCell(block) {
        var _a;
        const buf = new string_buffer_1.Buffer();
        (_a = block.children) === null || _a === void 0 ? void 0 : _a.forEach((childId) => {
            const child = this.blockMap[childId];
            buf.write(this.parseBlock(child, 0));
        });
        return buf.toString();
    }
    parseTable(table) {
        var _a, _b, _c;
        let rows = [[]];
        table.cells.forEach((blockId, idx) => {
            const block = this.blockMap[blockId];
            let cellText = this.parseBlock(block, 0);
            cellText = (0, types_1.trimLastNewline)(cellText).replace(/\n/, '<br/>');
            const row = Math.floor(idx / table.property.column_size);
            if (rows.length < row + 1) {
                rows.push([]);
            }
            rows[row].push(cellText);
        });
        const buf = new string_buffer_1.Buffer();
        // Write thead
        let headRow = [];
        if ((_a = table.property) === null || _a === void 0 ? void 0 : _a.header_row) {
            headRow = rows.shift();
        }
        buf.write('|');
        for (let i = 0; i < ((_b = table.property) === null || _b === void 0 ? void 0 : _b.column_size); i++) {
            buf.write(headRow[i] || '   ');
            buf.write('|');
        }
        buf.write('\n');
        // Render thead divider
        buf.write('|');
        for (let i = 0; i < ((_c = table.property) === null || _c === void 0 ? void 0 : _c.column_size); i++) {
            buf.write('---|');
        }
        buf.write('\n');
        // Render tbody
        for (const row of rows) {
            buf.write('|');
            row.forEach((cell) => {
                buf.write(cell);
                buf.write('|');
            });
            buf.write('\n');
        }
        return buf.toString();
    }
    parseQuoteContainer(block) {
        var _a;
        const buf = new string_buffer_1.Buffer();
        (_a = block.children) === null || _a === void 0 ? void 0 : _a.forEach((childId) => {
            const child = this.blockMap[childId];
            buf.write('> ');
            buf.write(this.parseBlock(child, 0));
        });
        return buf.toString();
    }
    parseView(block) {
        var _a;
        const buf = new string_buffer_1.Buffer();
        (_a = block.children) === null || _a === void 0 ? void 0 : _a.forEach((childId) => {
            const child = this.blockMap[childId];
            buf.write(this.parseBlock(child, 0));
        });
        return buf.toString();
    }
    parseFile(block) {
        const buf = new string_buffer_1.Buffer();
        const file = block.file;
        this.imageTokens.push(file.token);
        buf.write(`[${file.name}](${file.token})`);
        buf.write('\n');
        return buf.toString();
    }
    parseUnsupport(block) {
        if (!this.output_unsupported) {
            return '';
        }
        const buf = new string_buffer_1.Buffer();
        buf.write('```\n');
        buf.write(`// [Unsupport] ${types_1.BlockType[block.block_type]}\n`);
        buf.write(JSON.stringify(block, null, 2));
        buf.write('\n```\n');
        return buf.toString();
    }
}
exports.MarkdownRenderer = MarkdownRenderer;
//# sourceMappingURL=markdown_renderer.js.map