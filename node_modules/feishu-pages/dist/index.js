#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const doc_1 = require("./doc");
const feishu_1 = require("./feishu");
const summary_1 = require("./summary");
const utils_1 = require("./utils");
const wiki_1 = require("./wiki");
// App entry
(() => __awaiter(void 0, void 0, void 0, function* () {
    yield (0, feishu_1.fetchTenantAccessToken)();
    console.info('OUTPUT_DIR:', feishu_1.OUTPUT_DIR);
    console.info('FEISHU_APP_ID:', feishu_1.feishuConfig.appId);
    console.info('FEISHU_SPACE_ID:', feishu_1.feishuConfig.spaceId);
    console.info('ROOT_NODE_TOKEN:', feishu_1.ROOT_NODE_TOKEN);
    console.info('-------------------------------------------\n');
    // Map file_token to slug
    let slugMap = {};
    const docs = yield (0, wiki_1.fetchAllDocs)(feishu_1.feishuConfig.spaceId, 0, feishu_1.ROOT_NODE_TOKEN);
    yield fetchDocBodies(docs);
    (0, summary_1.prepareDocSlugs)(docs, slugMap);
    // Fetch docs contents and write files
    yield fetchDocAndWriteFile(feishu_1.DOCS_DIR, docs, slugMap);
    // Write SUMMARY.md
    const summary = (0, summary_1.generateSummary)(docs);
    fs_1.default.writeFileSync(path_1.default.join(feishu_1.DOCS_DIR, 'SUMMARY.md'), summary);
    // Omit hide docs
    cleanupDocsForJSON(docs);
    // Write docs.json
    fs_1.default.writeFileSync(path_1.default.join(feishu_1.OUTPUT_DIR, 'docs.json'), JSON.stringify(docs, null, 2));
}))();
const allowKeys = [
    'depth',
    'title',
    'slug',
    'filename',
    'node_token',
    'parent_node_token',
    'children',
    'obj_create_time',
    'obj_edit_time',
    'obj_token',
    'has_child',
    'meta',
    'position',
];
const cleanupDocsForJSON = (docs) => {
    var _a;
    for (let idx = 0; idx < docs.length; idx++) {
        const doc = docs[idx];
        Object.keys(doc).forEach((key) => {
            if (!allowKeys.includes(key)) {
                delete doc[key];
            }
        });
        if ((_a = doc.meta) === null || _a === void 0 ? void 0 : _a.hide) {
            docs.splice(idx, 1);
        }
        cleanupDocsForJSON(doc.children);
    }
};
const fetchDocBodies = (docs) => __awaiter(void 0, void 0, void 0, function* () {
    for (let idx = 0; idx < docs.length; idx++) {
        const doc = docs[idx];
        const { content, fileTokens, meta } = yield (0, doc_1.fetchDocBody)(doc.obj_token);
        doc.content = content;
        doc.meta = meta;
        doc.fileTokens = fileTokens;
        yield fetchDocBodies(doc.children);
    }
});
const fetchDocAndWriteFile = (outputDir, docs, slugMap) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    if (docs.length === 0) {
        return;
    }
    for (let idx = 0; idx < docs.length; idx++) {
        const doc = docs[idx];
        // Skip write the hide doc
        if ((_a = doc.meta) === null || _a === void 0 ? void 0 : _a.hide) {
            continue;
        }
        let filename = path_1.default.join(outputDir, doc.filename);
        const folder = path_1.default.dirname(filename);
        fs_1.default.mkdirSync(folder, { recursive: true });
        let { content, fileTokens } = doc;
        // TODO: Replace link's node_token into slug
        for (const node_token in slugMap) {
            // Replace Markdown link and HTML link
            const re = new RegExp(`${node_token}`, 'gm');
            const newLink = `${feishu_1.BASE_URL}${slugMap[node_token]}`;
            content = content.replace(re, newLink);
        }
        const metaInfo = (0, doc_1.generateFileMeta)(doc, doc.slug, doc.position);
        let out = '';
        out += metaInfo + '\n\n';
        content = yield downloadFiles(content, fileTokens, folder);
        out += content;
        console.info('Writing doc', doc.filename, (0, utils_1.humanizeFileSize)(content.length), '...');
        fs_1.default.writeFileSync(filename, out);
        yield fetchDocAndWriteFile(outputDir, doc.children, slugMap);
    }
});
/**
 * This alwasy download assets into ./assets into the docFolder (same folder as the doc).
 *
 * @param content
 * @param fileTokens
 * @param docFolder
 * @returns
 */
const downloadFiles = (content, fileTokens, docFolder) => __awaiter(void 0, void 0, void 0, function* () {
    for (const fileToken in fileTokens) {
        const filePath = yield (0, feishu_1.feishuDownload)(fileToken, path_1.default.join(path_1.default.join(docFolder, 'assets'), fileToken));
        if (!filePath) {
            continue;
        }
        const extension = path_1.default.extname(filePath);
        const re = new RegExp(`${fileToken}`, 'gm');
        content = content.replace(re, './assets/' + fileToken + extension);
    }
    return content;
});
